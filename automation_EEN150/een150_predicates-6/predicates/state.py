# -------------------------------------------------------------------------
# In this file, the state class is defined that we will use to represent 
# a state. You need to implement some of the missing functionality based 
# on the failing tests. 
# 
# -------------------------------------------------------------------------

from __future__ import annotations
from typing import Any, Optional
from dataclasses import dataclass
from predicates.errors import NextException, NotInStateException


@dataclass(frozen=True, order=True, init=False)
class State:
    state: dict[str, Any]
    """
    The state class is a wrapper class around a simple dictionary that stores
    the key - values of the state. The purpose is to avoid accidental changes 
    of a state and to support creating a new state when running an action

    The class is also a dataclass that simplify the creation of classes. So
    before you continue, learn some more about dataclasses:

    https://docs.python.org/3/library/dataclasses.html
    https://youtu.be/vBH6GRJ1REM

    We especially use a dataclass since it generates a lot of support methods so
    we can use states in sets and compare states.

    # To better understand eq and hash read more about it here: 
    # https://eng.lyft.com/hashing-and-equality-in-python-2ea8c738fb9d
    # Observe though, that when using @dataclass(frozen=True, order=True), these functions
    # are generated.
    """ 

    # The first three methods are already implemented

    # This init overrides the default __init__ generated by dataclass to allow the 
    # use of kwargs and to guarantee immutability
    def __init__(self, **kwargs) -> None:
        """
        Include the variables and their values when creating the state. e.g:
        state = State(v1 = False, v2 = True, v3 = "open") 
        dict = {"v1" = False, "v2" = True, "v3" = "open"}
        state2 = State(**dict)
        If you do not know what **kwargs is, read e.g. 
        https://book.pythontips.com/en/latest/args_and_kwargs.html
        or just google it.
        Below I also use object.__setattr__(...) to change the variable, which is 
        necessary since it is a frozen dataclass
        """
        object.__setattr__(self, "state", kwargs)

    def items(self):
        """
        An items view of the items in the state for iterations (so the state can not be changed)
        """
        return self.state.items()

    def contains(self, variable: str) -> bool:
        """
        Check if a variable is included in the state
        """
        return variable in self.state

    def get(self, variable: str) -> Any:
        """
        Will return the value a the variable or should raises an NotInStateException. Write a 
        nice message in the exception so that you know which key is not in the state
        """
        if variable in self.state.keys():
            return self.state[variable]
        else:
            raise NotInStateException(f"Key {variable} is not in state")

    def next(self, **kwargs) -> State:
        """
        This function returns a new State that is updated with
        the changed / new variable - value pairs given in kwargs
        """
        for kwarg in kwargs:
            if kwarg not in self.state.keys():
                raise NextException(f"Key {kwarg} not in state!")
        curr_dict = self.state.copy()
        curr_dict.update(kwargs)
        return State(**curr_dict)


    def __hash__(self) -> int:
        """We also need our own hash since dict are not hashable. Do not change"""
        return hash(tuple(sorted(self.state)))
